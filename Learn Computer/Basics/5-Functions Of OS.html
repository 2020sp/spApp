<!DOCTYPE html>
<head>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="HandheldFriendly" content="true">
</head>
<body>
<h2>Functions of OS</h2> <hr> </hr> <h1></h1> <p>As you know, operating system is responsible for functioning of the computer system. To do that it carries out these three broad categories of activities &minus;</p> <ul class="list"> <li> <p><strong>Essential functions</strong>&nbsp;&minus; Ensures optimum and effective utilization of resources</p> </li> <li> <p><strong>Monitoring functions</strong>&nbsp;&minus; Monitors and collects information related to system performance</p> </li> <li> <p><strong>Service functions</strong>&nbsp;&minus; Provides services to users</p> </li> </ul> <p>Let us look at some of the most important functions associated with these activities.</p> <h2>Processor management</h2> <p>Managing a computer&rsquo;s CPU to ensure its optimum utilization is called&nbsp;<strong>processor management</strong>. Managing processor basically involves allocating processor time to the tasks that need to be completed. This is called&nbsp;<strong>job scheduling</strong>. Jobs must be scheduled in such a way that &minus;</p> <ul class="list"> <li>There is maximum utilization of CPU</li> <li>Turnaround time, i.e. time required to complete each job, is minimum</li> <li>Waiting time is minimum</li> <li>Each job gets the fastest possible response time</li> <li>Maximum throughput is achieved, where throughput is the average time taken to complete each task</li> </ul> <p>There are two methods of job scheduling done by operating systems &minus;</p> <ul class="list"> <li>Preemptive scheduling</li> <li>Non-Preemptive scheduling</li> </ul> <p><img src="https://www.tutorialspoint.com/basics_of_computers/images/processor_management.jpg" alt="Processor Management" style="max-width:100%;height:auto;" /></p> <h2>Preemptive Scheduling</h2> <p>In this type of scheduling, next job to be done by the processor can be scheduled before the current job completes. If a job of higher priority comes up, the processor can be forced to release the current job and take up the next job. There are two scheduling techniques that use pre-emptive scheduling &minus;</p> <ul class="list"> <li> <p><strong>Round robin scheduling</strong>&nbsp;&minus; A small unit of time called&nbsp;<strong>time slice</strong>&nbsp;is defined and each program gets only one time slice at a time. If it is not completed during that time, it must join the job queue at the end and wait till all programs have got one time slice. The advantage here is that all programs get equal opportunity. The downside is that if a program completes execution before the time slice is over, CPU is idle for the rest of the duration.</p> </li> <li> <p><strong>Response ratio scheduling</strong>&nbsp;&minus; Response ratio is defined as</p> <div class="MathJax_Display"><span id="MathJax-Element-1-Frame" class="MathJax" style="box-sizing: border-box; display: inline; font-style: normal; font-weight: normal; line-height: normal; font-size: 15px; text-indent: 0px; text-align: center; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; position: relative;" tabindex="0" data-mathml="&lt;math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot; display=&quot;block&quot;&gt;&lt;mfrac&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;l&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;p&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;mspace width=&quot;mediummathspace&quot; /&gt;&lt;mi&gt;T&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;/mrow&gt;&lt;mrow&gt;&lt;mi&gt;E&lt;/mi&gt;&lt;mi&gt;x&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;u&lt;/mi&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mspace width=&quot;mediummathspace&quot; /&gt;&lt;mi&gt;t&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mspace width=&quot;mediummathspace&quot; /&gt;&lt;mi&gt;r&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;c&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;mi&gt;v&lt;/mi&gt;&lt;mi&gt;e&lt;/mi&gt;&lt;mi&gt;d&lt;/mi&gt;&lt;/mrow&gt;&lt;/mfrac&gt;&lt;/math&gt;"><span id="MathJax-Span-1" class="math"><span id="MathJax-Span-2" class="mrow"><span id="MathJax-Span-3" class="mfrac"><span id="MathJax-Span-4" class="mrow"><span id="MathJax-Span-5" class="mi">E</span><span id="MathJax-Span-6" class="mi">l</span><span id="MathJax-Span-7" class="mi">a</span><span id="MathJax-Span-8" class="mi">p</span><span id="MathJax-Span-9" class="mi">s</span><span id="MathJax-Span-10" class="mi">e</span><span id="MathJax-Span-11" class="mi">d</span><span id="MathJax-Span-12" class="mspace"></span><span id="MathJax-Span-13" class="mi">T</span><span id="MathJax-Span-14" class="mi">i</span><span id="MathJax-Span-15" class="mi">m</span><span id="MathJax-Span-16" class="mi">e</span></span><span id="MathJax-Span-17" class="mrow"><span id="MathJax-Span-18" class="mi">E</span><span id="MathJax-Span-19" class="mi">x</span><span id="MathJax-Span-20" class="mi">e</span><span id="MathJax-Span-21" class="mi">c</span><span id="MathJax-Span-22" class="mi">u</span><span id="MathJax-Span-23" class="mi">t</span><span id="MathJax-Span-24" class="mi">i</span><span id="MathJax-Span-25" class="mi">o</span><span id="MathJax-Span-26" class="mi">n</span><span id="MathJax-Span-27" class="mspace"></span><span id="MathJax-Span-28" class="mi">t</span><span id="MathJax-Span-29" class="mi">i</span><span id="MathJax-Span-30" class="mi">m</span><span id="MathJax-Span-31" class="mi">e</span><span id="MathJax-Span-32" class="mspace"></span><span id="MathJax-Span-33" class="mi">r</span><span id="MathJax-Span-34" class="mi">e</span><span id="MathJax-Span-35" class="mi">c</span><span id="MathJax-Span-36" class="mi">e</span><span id="MathJax-Span-37" class="mi">i</span><span id="MathJax-Span-38" class="mi">v</span><span id="MathJax-Span-39" class="mi">e</span><span id="MathJax-Span-40" class="mi">d</span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">ElapsedTimeExecutiontimereceived</span></span></div> <p>A job with shorter response time gets higher priority. So a larger program may have to wait even if it was requested earlier than the shorter program. This improves throughput of the CPU.</p> </li> </ul> <h2>Non-preemptive Scheduling</h2> <p>In this type of scheduling, job scheduling decisions are taken only after the current job completes. A job is never interrupted to give precedence to higher priority jobs. Scheduling techniques that use non-preemptive scheduling are &minus;</p> <ul class="list"> <li> <p><strong>First come first serve scheduling</strong>&nbsp;&minus; This is the simplest technique where the first program to throw up a request is completed first.</p> </li> <li> <p><strong>Shortest job next scheduling</strong>&nbsp;&minus; Here the job that needs least amount of time for execution is scheduled next.</p> </li> <li> <p><strong>Deadline scheduling</strong>&nbsp;&minus; The job with the earliest deadline is scheduled for execution next.</p> </li> </ul> <h2>Memory Management</h2> <p>Process of regulating computer memory and using optimization techniques to enhance overall system performance is called&nbsp;<strong>memory management</strong>. Memory space is very important in modern computing environment, so memory management is an important role of operating systems.</p> <p>As you know, computers have two types of memory &ndash;&nbsp;<strong>primary</strong>&nbsp;and&nbsp;<strong>secondary</strong>. Primary memory is&nbsp;<strong>fast but expensive</strong>&nbsp;and secondary memory is&nbsp;<strong>cheap but slower</strong>. OS has to strike a balance between the two to ensure that system performance is not hurt due to very less primary memory or system costs do not shoot up due to too much primary memory.</p> <p>Input and output data, user instructions and data interim to program execution need to be stored, accessed and retrieved efficiently for high system performance. Once a program request is accepted, OS allocates it primary and secondary storage areas as per requirement. Once execution is completed, the memory space allocated to it is freed. OS uses many storage management techniques to keep a track of all storage spaces that are allocated or free.</p> <h2>Contiguous Storage Allocation</h2> <p>This is the simplest storage space allocation technique where contiguous memory locations are assigned to each program. OS has to estimate the amount of memory required for the complete process before allocation.</p> <h2>Non-contiguous Storage Allocation</h2> <p>As the name suggests, program and associated data need not be stored in contiguous locations. The program is divided into smaller components and each component is stored in a separate location. A table keeps a record of where each component of the program is stored. When the processor needs to access any component, OS provides access using this allocation table.</p> <p>In a real-life scenario primary memory space might not be sufficient to store the whole program. In that case, OS takes the help of&nbsp;<strong>Virtual Storage</strong>technique, where program is physically stored in secondary memory but appears to be stored in primary memory. This introduces a miniscule time lag in accessing the program components. There are two approaches to virtual storages &minus;</p> <ul class="list"> <li> <p><strong>Program paging</strong>&nbsp;&minus; A program is broken down into fixed size&nbsp;<strong>page</strong>and stored in the secondary memory. The pages are given&nbsp;<strong>logical address or virtual address</strong>&nbsp;from 0 to n. A&nbsp;<strong>page table</strong>&nbsp;maps the logical addresses to the physical addresses, which is used to retrieve the pages when required.</p> </li> <li> <p><strong>Program segmentation</strong>&nbsp;&minus; A program is broken down into logical units called&nbsp;<strong>segments</strong>, assigned logical address from 0 to n and stored in secondary memory. A&nbsp;<strong>segment table</strong>&nbsp;is used to load segments from secondary memory to primary memory.</p> </li> </ul> <p>Operating systems typically use a combination of page and program segmentation to optimize memory usage. A large program segment may be broken into pages or more than one small segments may be stored as a single page.</p> <h2>File Management</h2> <p>Data and information is stored on computers in form of files. Managing file system to enable users to keep their data safely and correctly is an important function of operating systems. Managing file systems by OS is called&nbsp;<strong>file management</strong>. File management is required to provide tools for these file related activities &minus;</p> <ul class="list"> <li>Creating new files for storing data</li> <li>Updating</li> <li>Sharing</li> <li>Securing data through passwords and encryption</li> <li>Recovery in case of system failure</li> </ul> <h2>Device Management</h2> <p>The process of implementation, operation and maintenance of a device by operating system is called&nbsp;<strong>device management</strong>. Operating system uses a utility software called&nbsp;<strong>device driver</strong>&nbsp;as interface to the device.</p> <p>When many processes access the devices or request access to the devices, the OS manages the devices in a way that efficiently shares the devices among all processes. Processes access devices through&nbsp;<strong>system call interface</strong>, a programming interface provided by the OS.</p> <style type="text/css"> h2 { color:#0000FF; } 
img{width:100%;}
</style>
</body>
</html>